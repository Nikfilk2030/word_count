# Задача о нахождении количества слов в тексте

## Краткое описание

Дан файл. Нужно вывести `quanity word`, где `quantity` - количество встреч этого слова в файле. Слово - набор ascii, кроме пробелов. Пробел - разделитель

## Тестирование

Генератор тестов представлен в `test_generator.py`. Он сгенерирует входной `words.txt` и `decoded.txt`. Проверка своими красивыми глазками

## Однопоточное решение

Реализовано в `main.cpp` в виде функции

Из примечательного: красивый, чистый код дороже небольшого прироста в перфе, поэтому мы сделаем немного копирований, зато решение будет очень легко скейлится до многопоточного

Имеем тип данных `FrequencyVector`, который все сделает за нас, останется позвать только `.print()`

## Многопоточное решение

Реализовано в `main.cpp`

Я обдумывал два подхода

1) Много потоков читают свои батчи файла, одна глобальная многопоточная мапа служит для записи
    Решение имет место быть "в вакууме", когда "текст" - случайный набор букв, не задан определенный алфавит, мы не знаем, что это "реальная речь". В таких условиях такое решение будет оптимальным

2) Много потоко читают свои батчи файла, проводят для них однопоточное решение, а потом выход каждого однопоточного решения мерджится в одну "мегамапу"

Я остановился на втором подходе, и вот почему

Решение требует больше памяти (т.к для одних и тех же слов мы едим thread_count места), однако отлично справляется в случае "реальной речи" - мы никогда не делаем lock на mutex и потоки являются полностью независимыми

merge в случае большой речи тоже происходит очень быстро, потому что на деле мапы в основном состоят из самых частотных слов

Протестировать это предлагаю самостоятельно, покрутив thread_count

## Запуск

```bash
$ g++ main.cpp -o main -std=c++17

$ ./main -i <input_file_name> -o <output_file_name> (optional) --multithreaded
```
